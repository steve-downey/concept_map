<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Concept Maps using C++23 Library Tech</title>
<meta name="author" content="Steve Downey"/>
<meta name="description" content="

"/>
<meta name="keywords" content="  "/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./my_theme.css" id="theme"/>

<link rel="stylesheet" href="./operandi-tinted.css"/>

<link rel="stylesheet" href="./footer.css"/>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<link rel="stylesheet" type="text/css" href="./operandi-tinted.css" />
<link rel="stylesheet" type="text/css" href="http://sdowney.org/css/modus-operandi-tinted.css" />
A
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide" data-background="./concept_maps_title.png">
<h1 class="title">Concept Maps using C++23 Library Tech</h1>
</section>
<section>
<section id="slide-org327cfc3">
<h2 id="org327cfc3">Abstract</h2>
<p>
C++0x Concepts had a feature <code>Concept Maps</code> that allowed a set of functions, types, and template definitions to be associated with a concept and the map to be specialized for types that meet the concept.
</p>

<p class="fragment (appear)">
This allowed open extension of a concept.
</p>

<p class="fragment (appear)">
A definition could be provided that allows an algorithm to operate in terms of the API a concept presents and the map would define how those operations are implemented for a particular type.
</p>

<ul>
<li class="fragment appear">This is similar to how Haskell's <code>typeclass</code> works.</li>

</ul>


<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org7c0bc16">
<h3 id="org7c0bc16">Lost with <code>Concepts-Lite</code></h3>
<aside class="notes">
<p>
The feature was very general, and lost as part of the <code>Concepts-Lite</code> proposal that was eventually adopted.
</p>

<p>
This loss of a level of indirection means that the APIs for a concept must be implemented by those names for a type, even when those names are not particularly good choices in the natural domain of a type rather than in the domain as a concept.
</p>

<p>
The proliferation of <code>transform</code> functions for functorial <code>map</code> is such a problem.
</p>

<p>
It is also a problem when adapting types that are closed for extension or do not permit member functions.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org713368c">
<h2 id="org713368c">Why?</h2>
<ul>
<li class="fragment appear"><p>
Don't know if you should
</p></li>
<li class="fragment appear">Need to know if you could first</li>

</ul>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org10014b5">
<h3 id="org10014b5">Alternatives</h3>
<ul>
<li class="fragment appear"><p>
Virtual Interface
</p></li>
<li class="fragment appear"><p>
Adapters
</p></li>
<li class="fragment appear">Collection of CPOs</li>

</ul>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orga36e8a0">
<h3 id="orga36e8a0">Hard to Support</h3>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org409da8b">
<h2 id="org409da8b">Example from C++0x Concepts</h2>
<div class="outline-text-2" id="text-org409da8b">
</div>
</section>
</section>
<section>
<section id="slide-orga7701ea">
<h3 id="orga7701ea">Student Record</h3>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">student</span> <span class="org-type">record</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">public</span>:
  <span class="org-type">string</span> <span class="org-variable-name">id</span>;
  <span class="org-type">string</span> <span class="org-variable-name">name</span>;
  <span class="org-type">string</span> <span class="org-variable-name">address</span>;
  <span class="org-type">bool</span>   <span class="org-function-name">id_equal</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">student</span> <span class="org-variable-name">record</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">bool</span>   <span class="org-function-name">name_equal</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">student</span> <span class="org-variable-name">record</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">bool</span>   <span class="org-function-name">address_equal</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">student</span> <span class="org-variable-name">record</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org84bb684">
<h3 id="org84bb684">Equality Comparable</h3>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">concept_map</span> <span class="org-variable-use">EqualityComparable</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">student</span> <span class="org-variable-use">record</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-operator">==</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-keyword">const</span> <span class="org-type">student</span> <span class="org-variable-use">record</span><span class="org-operator">&amp;</span> <span class="org-variable-name">a</span><span class="org-delimiter">,</span>
                    <span class="org-keyword">const</span> <span class="org-type">student</span> <span class="org-variable-use">record</span><span class="org-operator">&amp;</span> <span class="org-variable-name">b</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">){</span></span>
        <span class="org-keyword">return</span> <span class="org-variable-use">a</span><span class="org-operator">.</span><span class="org-function-call">id_equal</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">(</span></span><span class="org-variable-use">b</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">)</span></span><span class="org-delimiter">;</span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">}</span></span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>
</pre>
</div>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgde61207">
<h3 id="orgde61207">Allow associated types</h3>
<p>
Very useful for pointers
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">concept_map</span> <span class="org-variable-use">BinaryFunction</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">int</span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-operator">*</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)(</span></span><span class="org-type">int</span><span class="org-delimiter">,</span> <span class="org-type">int</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">,</span> <span class="org-type">int</span><span class="org-delimiter">,</span> <span class="org-type">int</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
    <span class="org-keyword">typedef</span> <span class="org-type">int</span> <span class="org-type">result_type</span><span class="org-delimiter">;</span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>
</pre>
</div>


<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org8b02b93">
<h3 id="org8b02b93">Why Didn't We Get Them?</h3>
<p>
Let's not go there right now.
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org31c0369">
<h2 id="org31c0369">State of the Art</h2>
<div class="outline-text-2" id="text-org31c0369">
</div>
</section>
</section>
<section>
<section id="slide-org94ea95e">
<h3 id="org94ea95e">Rust Traits</h3>
<div class="org-src-container">

<pre class="src src-rust"><span class="org-keyword">trait</span> <span class="org-type">PartialEq</span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-operator">&amp;</span><span class="org-keyword">self</span><span class="org-delimiter">,</span> <span class="org-variable-name">rhs</span><span class="org-delimiter">:</span> <span class="org-operator">&amp;</span><span class="org-type">Self</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span> <span class="org-operator">-&gt;</span> <span class="org-type">bool</span><span class="org-delimiter">;</span>

    <span class="org-keyword">fn</span> <span class="org-function-name">ne</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-operator">&amp;</span><span class="org-keyword">self</span><span class="org-delimiter">,</span> <span class="org-variable-name">rhs</span><span class="org-delimiter">:</span> <span class="org-operator">&amp;</span><span class="org-type">Self</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span> <span class="org-operator">-&gt;</span> <span class="org-type">bool</span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">{</span></span>
        <span class="org-operator">!</span><span class="org-keyword">self</span><span class="org-delimiter">.</span><span class="org-function-call">eq</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">(</span></span><span class="org-variable-use">rhs</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">)</span></span>
    <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">}</span></span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>
</pre>
</div>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgb1f6dc7">
<h3 id="orgb1f6dc7">C++ CPOs</h3>
<div class="outline-text-3" id="text-orgb1f6dc7">
</div>
</section>
</section>
<section>
<section id="slide-org4fbc7d3">
<h4 id="org4fbc7d3">Some Concepts and Types</h4>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">namespace</span> <span class="org-constant">N</span>::<span class="org-constant">hidden</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
<span class="org-keyword">concept</span> <span class="org-type">has_eq</span> = <span class="org-keyword">requires</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-rainbow-delimiters-depth-3">{</span> eq<span class="org-rainbow-delimiters-depth-4">(</span>v, v<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
<span class="org-rainbow-delimiters-depth-2">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">eq_fn</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">has_eq</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-3">()</span></span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">x</span>,
                            <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">return</span> eq<span class="org-rainbow-delimiters-depth-4">(</span>x, y<span class="org-rainbow-delimiters-depth-4">)</span>;
  <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">has_eq</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-function-name">ne</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">x</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-keyword">return</span> <span class="org-keyword">not</span> eq<span class="org-rainbow-delimiters-depth-3">(</span>x, y<span class="org-rainbow-delimiters-depth-3">)</span>;
<span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
<span class="org-keyword">concept</span> <span class="org-type">has_ne</span> = <span class="org-keyword">requires</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-rainbow-delimiters-depth-3">{</span> ne<span class="org-rainbow-delimiters-depth-4">(</span>v, v<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
<span class="org-rainbow-delimiters-depth-2">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">ne_fn</span> <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">has_ne</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-3">()</span></span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">x</span>,
                            <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">return</span> ne<span class="org-rainbow-delimiters-depth-4">(</span>x, y<span class="org-rainbow-delimiters-depth-4">)</span>;
  <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">namespace N::hidden</span>
</pre>
</div>

<p>
See <span class="underline">Why tag_invoke is not the solution I want</span> by Barry Revzin
<a href="https://brevzin.github.io/c++/2020/12/01/tag-invoke/">https://brevzin.github.io/c++/2020/12/01/tag-invoke/</a>
</p>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org26a2499">
<h4 id="org26a2499">C++ partial_equality</h4>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">namespace</span> <span class="org-constant">N</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">inline</span> <span class="org-keyword">namespace</span> <span class="org-constant">function_objects</span> <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-constant">hidden</span>::<span class="org-type">eq_fn</span> <span class="org-variable-name">eq</span><span class="org-rainbow-delimiters-depth-3">{}</span>;
<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-constant">hidden</span>::<span class="org-type">ne_fn</span> <span class="org-variable-name">ne</span><span class="org-rainbow-delimiters-depth-3">{}</span>;
<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">namespace function_objects</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
<span class="org-keyword">concept</span> partial_equality
  <span class="org-keyword">requires</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">remove_reference_t</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-2">{</span>
  eq<span class="org-rainbow-delimiters-depth-3">(</span>t, t<span class="org-rainbow-delimiters-depth-3">)</span>;
  ne<span class="org-rainbow-delimiters-depth-3">(</span>t, t<span class="org-rainbow-delimiters-depth-3">)</span>;
<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">namespace N</span>
</pre>
</div>
<p>
See <span class="underline">Why tag_invoke is not the solution I want</span> by Barry Revzin
<a href="https://brevzin.github.io/c++/2020/12/01/tag-invoke/">https://brevzin.github.io/c++/2020/12/01/tag-invoke/</a>
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org245ab84">
<h2 id="org245ab84">Requirements for Solution</h2>
<ul>
<li class="fragment appear"><p>
Tied to the type system
</p></li>
<li class="fragment appear"><p>
Automatable
</p></li>
<li class="fragment appear">"zero" overhead
<ul>
<li class="fragment appear"><p>
no virtual calls
</p></li>
<li class="fragment appear">no type erasure</li>

</ul></li>

</ul>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org422501c">
<h2 id="org422501c">What does typeclass do?</h2>
<p class="fragment (appear)">
Adds a record to the function that defines the operations for the type.
</p>

<p class="fragment (appear)">
Can we do that?
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgac05252">
<h2 id="orgac05252">Type-based lookup</h2>
<p class="fragment (appear)">
Templates!
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org8607d77">
<h2 id="org8607d77">Additional Requirements</h2>
<p class="fragment (appear)">
Avoid ADL
</p>
<p class="fragment (appear)">
Object Lookup rather than Overload Lookup
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orge42e473">
<h2 id="orge42e473">Variable templates</h2>
<p class="fragment (appear)">
Variable templates have become more powerful
</p>

<p class="fragment (appear)">
We can have entirely distinct specializations
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org9b6887c">
<h3 id="org9b6887c">A Step Towards Implementation</h3>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">concept</span> <span class="org-type">partial_equality</span> = <span class="org-keyword">requires</span><span class="org-rainbow-delimiters-depth-1">(</span>
    <span class="org-constant">std</span>::<span class="org-type">remove_reference_t</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">partial_eq</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>.eq<span class="org-rainbow-delimiters-depth-3">(</span>t, t<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-2">}</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">partial_eq</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>.ne<span class="org-rainbow-delimiters-depth-3">(</span>t, t<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-2">}</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org8707fff">
<h3 id="org8707fff"><code>partial_eq&lt;T&gt;</code></h3>
<div class="outline-text-3" id="text-org8707fff">
</div>
</section>
</section>
<section>
<section id="slide-org62be497">
<h4 id="org62be497">An inline variable object</h4>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">template</span><span class="org-operator">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-operator">&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-keyword">inline</span> <span class="org-keyword">auto</span> <span class="org-variable-name">partial_eq</span> <span class="org-operator">=</span> <span class="org-constant">hidden</span>::<span class="org-variable-use">partial_eq_default</span><span class="org-delimiter">;</span>
</pre>
</div>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org388d09c">
<h4 id="org388d09c">A default implementation</h4>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">constexpr</span> <span class="org-keyword">inline</span> <span class="org-keyword">struct</span> <span class="org-type">partial_eq_default_t</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>
  <span class="org-function-name">eq</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">has_eq</span> <span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span>,
     <span class="org-type">has_eq</span> <span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">(</span>rhs == lhs<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>
  <span class="org-function-name">ne</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">has_eq</span> <span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span>,
     <span class="org-type">has_eq</span> <span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">(</span>lhs != rhs<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-variable-name">partial_eq_default</span>;
</pre>
</div>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org470c282">
<h4 id="org470c282">New <code>has_eq</code></h4>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">template</span> <span class="org-operator">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-operator">&gt;</span>
<span class="org-keyword">concept</span> <span class="org-variable-use">has_eq</span> <span class="org-operator">=</span> <span class="org-keyword">requires</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">T</span> <span class="org-keyword">const</span><span class="org-operator">&amp;</span> <span class="org-variable-name">v</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
  <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">{</span></span> <span class="org-variable-use">operator</span><span class="org-operator">==</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">(</span></span><span class="org-variable-use">v</span><span class="org-delimiter">,</span> <span class="org-variable-use">v</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">}</span></span> <span class="org-operator">-&gt;</span> <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&lt;</span></span><span class="org-type">bool</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&gt;</span></span><span class="org-delimiter">;</span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>
</pre>
</div>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org4361428">
<h3 id="org4361428">Will do better</h3>
<p class="fragment (appear)">
In a bit
</p>


<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orge4d9ed9">
<h2 id="orge4d9ed9">Monoid</h2>
<p class="fragment (appear)">
A little more than you think.
</p>

<ul>
<li class="fragment appear">A type</li>
<li class="fragment appear">With an associative binary operation</li>
<li class="fragment appear">Which is closed</li>
<li class="fragment appear">And has an identity element</li>

</ul>
</section>
</section>
<section>
<section id="slide-org7fb02d2">
<h3 id="org7fb02d2">Maybe not a lot more</h3>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org1719e70">
<h3 id="org1719e70">Math</h3>
<ul>
<li class="fragment appear">\(\oplus: M \times M \rightarrow M\)</li>
<li class="fragment appear">\(x \oplus (y \oplus z) = (x \oplus y) \oplus z\)</li>
<li class="fragment appear">\(1_M \in M\) such that \(\forall m \in M : (1_M \oplus m) = m = (m \oplus 1_M)\)</li>

</ul>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgf5661a1">
<h3 id="orgf5661a1">Function form</h3>
<ul>
<li class="fragment appear">\(f : M \times M \rightarrow M\)</li>
<li class="fragment appear">\(f(x, f(y, z)) = f(f(x, y), z)\)</li>
<li class="fragment appear">\(1_M \in M\) such that \(\forall m \in M : f(1_M, m) = m = f(m, 1_M)\)</li>

</ul>

<p class="fragment (appear)">
The similarity to left and right fold is <b>NOT</b> an accident
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-org6a0dc44">
<h3 id="org6a0dc44">Core Functions</h3>
<dl>
<dt class="fragment appear">\(empty : m\)</dt><dd class="fragment appear">\(empty = concat \, []\)</dd>
<dt class="fragment appear">\(concat : [m] \rightarrow m\)</dt><dd class="fragment appear">\(fold \, append \, empty\)</dd>
<dt class="fragment appear">\(append : m \rightarrow m \rightarrow m\)</dt><dd class="fragment appear">\(op\)</dd>

</dl>


<p class="fragment (appear)">
Note that it's self-referential
</p>

<p class="fragment (appear)">
This is common
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgc211629">
<h4 id="orgc211629">From Haskell Prelude</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Semigroup</span> a <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Monoid</span> a <span class="org-haskell-keyword">where</span>
  mempty <span class="org-haskell-operator">::</span> a
  mempty <span class="org-haskell-operator">=</span> mconcat <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>

  mappend <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a
  mappend <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>

  mconcat <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> a
  mconcat <span class="org-haskell-operator">=</span> foldr mappend mempty
</pre>
</div>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orge9a9bd9">
<h3 id="orge9a9bd9">Minimum Set</h3>
<p class="fragment (appear)">
\(empty \, | \, concat\)
</p>

<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgec207bd">
<h3 id="orgec207bd">In C++</h3>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-type">M</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">concept</span> <span class="org-type">MonoidRequirements</span> =
    <span class="org-keyword">requires</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-rainbow-delimiters-depth-2">{</span> i.identity<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">M</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
    <span class="org-rainbow-delimiters-depth-1">}</span>
    ||
    <span class="org-keyword">requires</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">i</span>, <span class="org-constant">std</span>::<span class="org-constant">ranges</span>::<span class="org-type">empty_view</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">M</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">r1</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-rainbow-delimiters-depth-2">{</span> i.concat<span class="org-rainbow-delimiters-depth-3">(</span>r1<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">}</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">same_as</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">M</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
    <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
<aside class="notes">
<p>
I am ignoring all sorts of const volatile reference issues here.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org2299333">
<h2 id="org2299333">Implementing the other side</h2>
<div class="outline-text-2" id="text-org2299333">
</div>
</section>
</section>
<section>
<section id="slide-orgcfa5ef7">
<h3 id="orgcfa5ef7">The Map for a Monoid</h3>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">template</span> <span class="org-operator">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Impl</span><span class="org-operator">&gt;</span>
  <span class="org-keyword">requires</span> <span class="org-type">MonoidRequirements</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span>
      <span class="org-type">Impl</span><span class="org-delimiter">,</span>
      <span class="org-keyword">typename</span> <span class="org-constant">Impl</span>::<span class="org-type">value_type</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">struct</span> <span class="org-type">Monoid</span> <span class="org-delimiter">:</span> <span class="org-keyword">protected</span> <span class="org-type">Impl</span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
  <span class="org-keyword">auto</span> <span class="org-function-name">identity</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-type">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>

  <span class="org-keyword">template</span> <span class="org-operator">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Range</span><span class="org-operator">&gt;</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">concat</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-keyword">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-delimiter">,</span> <span class="org-type">Range</span> <span class="org-variable-name">r</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>

  <span class="org-keyword">auto</span> <span class="org-function-name">op</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-type">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">a1</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">a2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>
</pre>
</div>
<aside class="notes">
<p>
empty is a terrible name, concat only a little better.
empty becomes identity
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org1181505">
<h4 id="org1181505"><code>identity</code></h4>
<div class="org-src-container">

<pre class="src src-c++">    <span class="org-keyword">auto</span> <span class="org-function-name">identity</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-keyword">this</span> <span class="org-keyword">auto</span> <span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
        <span class="org-constant">std</span>::<span class="org-variable-use">puts</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-string">"Monoid::identity()"</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
        <span class="org-keyword">return</span> <span class="org-variable-use">self</span><span class="org-operator">.</span><span class="org-function-call">concat</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-constant">std</span>::<span class="org-constant">ranges</span>::<span class="org-type">empty_view</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-3">&lt;</span></span><span class="org-keyword">typename</span> <span class="org-constant">Impl</span>::<span class="org-type">value_type</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-3">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">{}</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
    <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>

</pre>
</div>
</section>
</section>
<section>
<section id="slide-org588d174">
<h4 id="org588d174"><code>concat</code></h4>
<div class="org-src-container">

<pre class="src src-c++">   <span class="org-keyword">template</span><span class="org-operator">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Range</span><span class="org-operator">&gt;</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">concat</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-keyword">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-delimiter">,</span> <span class="org-type">Range</span> <span class="org-variable-name">r</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
        <span class="org-constant">std</span>::<span class="org-variable-use">puts</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-string">"Monoid::concat()"</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-constant">ranges</span>::<span class="org-variable-use">fold_right</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-variable-use">r</span><span class="org-delimiter">,</span>
                    <span class="org-variable-use">self</span><span class="org-operator">.</span><span class="org-function-call">identity</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">()</span></span><span class="org-delimiter">,</span>
                    <span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">[</span></span><span class="org-operator">&amp;</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">](</span></span><span class="org-keyword">auto</span> <span class="org-variable-name">m1</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">m2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">){</span></span><span class="org-keyword">return</span> <span class="org-variable-use">self</span><span class="org-operator">.</span><span class="org-function-call">op</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">(</span></span><span class="org-variable-use">m1</span><span class="org-delimiter">,</span> <span class="org-variable-use">m2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">)</span></span><span class="org-delimiter">;</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">}</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
    <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>

</pre>
</div>
</section>
</section>
<section>
<section id="slide-org439bc30">
<h4 id="org439bc30"><code>op</code></h4>
<div class="org-src-container">

<pre class="src src-c++">   <span class="org-keyword">auto</span> <span class="org-function-name">op</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-keyword">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">a1</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">a2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
        <span class="org-constant">std</span>::<span class="org-variable-use">puts</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-string">"Monoid::op"</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
        <span class="org-keyword">return</span> <span class="org-variable-use">self</span><span class="org-operator">.</span><span class="org-function-call">op</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-variable-use">a1</span><span class="org-delimiter">,</span> <span class="org-variable-use">a2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-delimiter">;</span>
    <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>
</pre>
</div>
</section>
</section>
<section>
<section id="slide-orge6d290e">
<h3 id="orge6d290e">Deducing <code>this</code> <b>and</b> CRTP</h3>
<p class="fragment (appear)">
We'll see in a moment, but it's because we want to constraint the required implementation.
</p>

<p class="fragment (appear)">
We want to use the derived version which has all of the operations.
</p>
</section>
</section>
<section>
<section id="slide-org7500308">
<h3 id="org7500308"><code>Plus</code></h3>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">M</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Plus</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-keyword">public</span>:
  <span class="org-keyword">using</span> <span class="org-type">value_type</span> = M;
  <span class="org-keyword">auto</span> <span class="org-variable-name">identity</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">this</span> <span class="org-keyword">auto</span>&amp;&amp; self<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">M</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Plus::identity()"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> M<span class="org-rainbow-delimiters-depth-3">{</span>0<span class="org-rainbow-delimiters-depth-3">}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">auto</span> <span class="org-variable-name">op</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">this</span> <span class="org-keyword">auto</span>&amp;&amp; self, <span class="org-keyword">auto</span> <span class="org-variable-name">s1</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">s2</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">M</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Plus::op()"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> s1 + s2;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
</section>
<section>
<section id="slide-org1573cf7">
<h3 id="org1573cf7"><code>PlusMonoidMap</code></h3>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">template</span><span class="org-operator">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">M</span><span class="org-operator">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">PlusMonoidMap</span> <span class="org-delimiter">:</span> <span class="org-keyword">public</span> <span class="org-type">Monoid</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">Plus</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&lt;</span></span><span class="org-type">M</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&gt;</span></span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
    <span class="org-keyword">using</span> <span class="org-type">Plus</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&lt;</span></span><span class="org-type">M</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&gt;</span></span>::<span class="org-variable-use">identity</span><span class="org-delimiter">;</span>
    <span class="org-keyword">using</span> <span class="org-type">Plus</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&lt;</span></span><span class="org-type">M</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-2">&gt;</span></span>::<span class="org-variable-use">op</span><span class="org-delimiter">;</span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>
</pre>
</div>
<aside class="notes">
<p>
Need to pull the operations from the Monoid instance into the Map, so we get the right ones being used by concat.
</p>

<p>
This might be simpler if we didn't allow choice of the basis operations, but that's also overly restrictive.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orgd85fc7c">
<h3 id="orgd85fc7c">The map instances</h3>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">template</span><span class="org-operator">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-operator">&gt;</span> <span class="org-keyword">auto</span> <span class="org-variable-name">monoid_concept_map</span> <span class="org-operator">=</span> <span class="org-constant">std</span>::<span class="org-type">false_type</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{}</span></span><span class="org-delimiter">;</span>

<span class="org-keyword">template</span><span class="org-operator">&lt;&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-keyword">inline</span> <span class="org-keyword">auto</span> <span class="org-variable-use">monoid_concept_map</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">int</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-operator">=</span> <span class="org-type">PlusMonoidMap</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">int</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{}</span></span><span class="org-delimiter">;</span>

<span class="org-keyword">template</span><span class="org-operator">&lt;&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-keyword">inline</span> <span class="org-keyword">auto</span> <span class="org-variable-use">monoid_concept_map</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">long</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-operator">=</span> <span class="org-type">PlusMonoidMap</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">long</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{}</span></span><span class="org-delimiter">;</span>

<span class="org-keyword">template</span><span class="org-operator">&lt;&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-keyword">inline</span> <span class="org-keyword">auto</span> <span class="org-variable-use">monoid_concept_map</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">char</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-operator">=</span> <span class="org-type">PlusMonoidMap</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">char</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{}</span></span><span class="org-delimiter">;</span>
</pre>
</div>
</section>
</section>
<section>
<section id="slide-orgc7ed85d">
<h3 id="orgc7ed85d">Can we <code>concat</code> instead?</h3>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">class</span> <span class="org-type">StringMonoid</span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
<span class="org-keyword">public</span><span class="org-delimiter">:</span>
  <span class="org-keyword">using</span> <span class="org-type">value_type</span> <span class="org-operator">=</span> <span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-delimiter">;</span>

  <span class="org-keyword">auto</span> <span class="org-function-name">op</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-type">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">s1</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">s2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">{</span></span>
    <span class="org-constant">std</span>::<span class="org-variable-use">puts</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">(</span></span><span class="org-string">"StringMonoid::op()"</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">)</span></span><span class="org-delimiter">;</span>
    <span class="org-keyword">return</span> <span class="org-variable-use">s1</span> <span class="org-operator">+</span> <span class="org-variable-use">s2</span><span class="org-delimiter">;</span>
  <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">}</span></span>

  <span class="org-keyword">template</span> <span class="org-operator">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Range</span><span class="org-operator">&gt;</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">concat</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-keyword">this</span> <span class="org-keyword">auto</span><span class="org-operator">&amp;&amp;</span> <span class="org-variable-name">self</span><span class="org-delimiter">,</span> <span class="org-type">Range</span> <span class="org-variable-name">r</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">{</span></span>
    <span class="org-constant">std</span>::<span class="org-variable-use">puts</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">(</span></span><span class="org-string">"StringMonoid::concat()"</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">)</span></span><span class="org-delimiter">;</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-constant">ranges</span>::<span class="org-variable-use">fold_right</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">(</span></span>
        <span class="org-variable-use">r</span><span class="org-delimiter">,</span> <span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">{}</span></span><span class="org-delimiter">,</span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">[</span></span><span class="org-operator">&amp;</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">](</span></span><span class="org-keyword">auto</span> <span class="org-variable-name">m1</span><span class="org-delimiter">,</span> <span class="org-keyword">auto</span> <span class="org-variable-name">m2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">)</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">{</span></span>
          <span class="org-keyword">return</span> <span class="org-variable-use">self</span><span class="org-operator">.</span><span class="org-function-call">op</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-5">(</span></span><span class="org-variable-use">m1</span><span class="org-delimiter">,</span> <span class="org-variable-use">m2</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-5">)</span></span><span class="org-delimiter">;</span>
        <span class="org-bracket"><span class="org-rainbow-delimiters-depth-4">}</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-3">)</span></span><span class="org-delimiter">;</span>
  <span class="org-bracket"><span class="org-rainbow-delimiters-depth-2">}</span></span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>
</pre>
</div>
<aside class="notes">
<p>
No, I'm not properly constraining Range here.
No, I'm not actually recommending this as an implementation.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org78a4578">
<h3 id="org78a4578">The Map and instance</h3>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">StringMonoidMap</span> <span class="org-delimiter">:</span> <span class="org-keyword">public</span> <span class="org-type">Monoid</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">StringMonoid</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{</span></span>
    <span class="org-keyword">using</span> <span class="org-constant">StringMonoid</span>::<span class="org-variable-use">op</span><span class="org-delimiter">;</span>
    <span class="org-keyword">using</span> <span class="org-constant">StringMonoid</span>::<span class="org-variable-use">concat</span><span class="org-delimiter">;</span>
<span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">}</span></span><span class="org-delimiter">;</span>

<span class="org-keyword">template</span><span class="org-operator">&lt;&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-keyword">inline</span> <span class="org-keyword">auto</span> <span class="org-variable-use">monoid_concept_map</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-operator">=</span> <span class="org-type">StringMonoidMap</span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">{}</span></span><span class="org-delimiter">;</span>

</pre>
</div>
</section>
</section>
<section>
<section id="slide-org912876f">
<h2 id="org912876f">Some simple use</h2>
<div class="outline-text-2" id="text-org912876f">
</div>
</section>
</section>
<section>
<section id="slide-org9abc3e0">
<h3 id="org9abc3e0">Exercise the functions</h3>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">P</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">testP</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">d1</span> = <span class="org-type">monoid_concept_map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">P</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = d1.identity<span class="org-rainbow-delimiters-depth-2">()</span>;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>P<span class="org-rainbow-delimiters-depth-3">{}</span> == x<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">sum</span> = d1.op<span class="org-rainbow-delimiters-depth-2">(</span>x, P<span class="org-rainbow-delimiters-depth-3">{</span>1<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>P<span class="org-rainbow-delimiters-depth-3">{</span>1<span class="org-rainbow-delimiters-depth-3">}</span> == sum<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">P</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">v</span> = <span class="org-rainbow-delimiters-depth-2">{</span>1,2,3,4<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">k</span> = d1.concat<span class="org-rainbow-delimiters-depth-2">(</span>v<span class="org-rainbow-delimiters-depth-2">)</span>;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>k == 10<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</section>
</section>
<section>
<section id="slide-org80cd9dc">
<h3 id="org80cd9dc">Some simple cases</h3>
<div class="org-src-container">

<pre class="src src-c++">    <span class="org-constant">std</span>::<span class="org-variable-use">cout</span> <span class="org-operator">&lt;&lt;</span> <span class="org-string">"</span><span class="org-escape">\n</span><span class="org-string">test int</span><span class="org-escape">\n</span><span class="org-string">"</span><span class="org-delimiter">;</span>
    <span class="org-variable-use">testP</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">int</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">()</span></span><span class="org-delimiter">;</span>

    <span class="org-constant">std</span>::<span class="org-variable-use">cout</span> <span class="org-operator">&lt;&lt;</span> <span class="org-string">"</span><span class="org-escape">\n</span><span class="org-string">test long</span><span class="org-escape">\n</span><span class="org-string">"</span><span class="org-delimiter">;</span>
    <span class="org-variable-use">testP</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">long</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">()</span></span><span class="org-delimiter">;</span>

   <span class="org-constant">std</span>::<span class="org-variable-use">cout</span> <span class="org-operator">&lt;&lt;</span> <span class="org-string">"</span><span class="org-escape">\n</span><span class="org-string">test char</span><span class="org-escape">\n</span><span class="org-string">"</span><span class="org-delimiter">;</span>
    <span class="org-variable-use">testP</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-type">char</span><span class="org-operator"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span><span class="org-bracket"><span class="org-rainbow-delimiters-depth-1">()</span></span><span class="org-delimiter">;</span>

</pre>
</div>
</section>
</section>
<section>
<section id="slide-org7697433">
<h3 id="org7697433">On <code>std::string</code></h3>
<p>
This will use the StringMonoid we defined a few moments ago.
</p>

<div class="org-src-container">

<pre class="src src-C++">    <span class="org-keyword">auto</span> <span class="org-variable-name">d2</span> = <span class="org-type">monoid_concept_map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\ntest string\n"</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">x2</span> = d2.identity<span class="org-rainbow-delimiters-depth-1">()</span>;
    assert<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{}</span> == x2<span class="org-rainbow-delimiters-depth-1">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">sum2</span> = d2.op<span class="org-rainbow-delimiters-depth-1">(</span>x2, <span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
    assert<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-2">}</span> == sum2<span class="org-rainbow-delimiters-depth-1">)</span>;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">vs</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"1"</span>,<span class="org-string">"2"</span>,<span class="org-string">"3"</span>,<span class="org-string">"4"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">k2</span> = d2.concat<span class="org-rainbow-delimiters-depth-1">(</span>vs<span class="org-rainbow-delimiters-depth-1">)</span>;
    assert<span class="org-rainbow-delimiters-depth-1">(</span>k2 == <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"1234"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Note that the map type is mostly invisible.
</p>
</section>
</section>
<section>
<section id="slide-orgbc12efe">
<h3 id="orgbc12efe">Results</h3>
<div class="outline-text-3" id="text-orgbc12efe">
</div>
</section>
</section>
<section>
<section id="slide-org78b05ae">
<h4 id="org78b05ae">test int</h4>
<pre class="example" id="orgd870a7c">
Plus::identity()
Plus::op()
Monoid::concat()
Plus::identity()
Plus::op()
Plus::op()
Plus::op()
Plus::op()
</pre>
</section>
</section>
<section>
<section id="slide-orgbdca9af">
<h4 id="orgbdca9af">test long</h4>
<pre class="example" id="org68a5c6d">
Plus::identity()
Plus::op()
Monoid::concat()
Plus::identity()
Plus::op()
Plus::op()
Plus::op()
Plus::op()
</pre>
</section>
</section>
<section>
<section id="slide-org69ba825">
<h4 id="org69ba825">test char</h4>
<pre class="example" id="org1d99720">
Plus::identity()
Plus::op()
Monoid::concat()
Plus::identity()
Plus::op()
Plus::op()
Plus::op()
Plus::op()
</pre>
</section>
</section>
<section>
<section id="slide-org81233c3">
<h4 id="org81233c3">test string</h4>
<pre class="example" id="org923da7d">
Monoid::identity()
StringMonoid::concat()
StringMonoid::op()
StringMonoid::concat()
StringMonoid::op()
StringMonoid::op()
StringMonoid::op()
StringMonoid::op()
</pre>
</section>
</section>
<section>
<section id="slide-org49c747b">
<h2 id="org49c747b">Monoid in Trees</h2>
<div class="outline-text-2" id="text-org49c747b">
</div>
</section>
</section>
<section>
<section id="slide-orgcedd382">
<h3 id="orgcedd382">Foldable generalizes</h3>
<p class="fragment (appear)">
Folding is very much tied to Range like things.
</p>

<p class="fragment (appear)">
It can, and has, been generalized to things that can be traversed.
</p>

<p class="fragment (appear)">
<code>monoids</code> are still critical for Traversables.
</p>
</section>
</section>
<section>
<section id="slide-orgb81d1e1">
<h3 id="orgb81d1e1">Summarizing Data in a tree</h3>
<p class="fragment (appear)">
If the summary type is monoidal, nodes can hold summaries of all the data below them.
</p>
</section>
</section>
<section>
<section id="slide-org684048e">
<h3 id="org684048e"><code>fingertrees</code></h3>
<p class="fragment (appear)">
Much of the flexibility of <code>fingertrees</code> comes from the monoidal tags.
</p>

<p class="fragment (appear)">
They are also fairly complicated.
</p>

<p class="fragment (appear)">
Technique can be applied to other, simpler trees.
</p>

<p class="fragment (appear)">
P3200 (eventually) ((C++29))
</p>
</section>
</section>
<section>
<section id="slide-orgedfdd52">
<h3 id="orgedfdd52">fringe-tree</h3>
<p>
Simplified tree with data at the edges
</p>
</section>
</section>
<section>
<section id="slide-orgc4cf2ec">
<h3 id="orgc4cf2ec">Code</h3>
<p>
Show the monoid-map branch of
</p>

<p>
<a href="https://github.com/steve-downey/fringetree">steve-downey/fringetree.git</a>
</p>
</section>
</section>
<section>
<section id="slide-orgc60b5e6">
<h2 id="orgc60b5e6">Summary for Concept Maps</h2>
<p>
Tell you what I told you
</p>

<ul>
<li>Variable templates for map lookup</li>
<li>Named operations on the map object</li>
<li>Open for extension</li>
<li>Concept checkable implementations</li>
<li>Decoupled map use and implementation</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgcb85249">
<h2 id="orgcb85249">Questions?</h2>
<p>
Or comments
</p>
</section>
</section>
<section>
<section id="slide-orge0f2a5e">
<h2 id="orge0f2a5e">Thank You</h2>
<aside class="notes">
<p>

</p>

</aside>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/search/search.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1600,
height: 900,

transition: 'fade',
transitionSpeed: 'default',
showNotes: window.location.search.match( /print-pdf/gi ) ? 'separate-page' : false,

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
